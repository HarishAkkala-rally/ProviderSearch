//package com.rallyhealth.chopshop.server.v8.model
//
//import java.util.concurrent.ThreadLocalRandom
//import com.rallyhealth.chopshop.client.v9.play.Binders
//import play.api.libs.json.Format
//import play.api.libs.json.ops.v4.FormatOps
//import com.rallyhealth.weepickle.v1.WeePickle.{fromTo, macroFromTo, FromTo}
//
//import scala.language.implicitConversions
//import scala.util.Try
//
///**
//  * Connect has several notions of a "User ID":
//  *   1: A Connect-internal hash of PII which is generated at SSO time and known as a "Connect User ID" or
//  *      "Connect User Hash". This can be represented as a 32-character dash-stripped UUID or a
//  *      truncated 24-character dash-stripped UUID.
//  *
//  *   2: A Rally-wide user identifier, "Rally ID". This comes from AuthN and can be correlated to RallyIDs from
//  *      other Rally products. It can be represented as a full 32-character UUID or a 24-character MongoDB ObjectID.
//  *
//  *   3: A randomly generated Guest User ID. This is produced by concatenating the word "guest" and a random [[Long]].
//  *
//  */
//sealed trait UserId {
//  def id: String
//
//  override def toString: String = id
//}
//
//object UserId {
//
//  val UUIDRegex = "^([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$".r
//
//  def applyOption(
//   id: String
//  ): Option[UserId] = AuthenticatedUserId.applyOption(id)
//
//  def apply(
//   id: String
//  ): UserId =
//    applyOption(id).getOrElse(
//      throw new IllegalArgumentException(s"Failed to validate id=$id as an authenticated id or guest id")
//    )
//
//  implicit val pickler: FromTo[UserId] = fromTo[String].bimap[UserId](_.id, UserId.apply)
//
//}
//
//sealed trait AuthenticatedUserId extends UserId
//
//object AuthenticatedUserId {
//
//  def applyOption(
//   id: String
//  ): Option[AuthenticatedUserId] = RallyId.applyOption(id).orElse(ConnectUserId.applyOption(id))
//
//  def apply(
//    id: String
//  ): AuthenticatedUserId =
//    applyOption(id).getOrElse(
//      throw new IllegalArgumentException(
//        s"Unable to identify what kind of AuthenticatedUserId id=$id is supposed to be."
//      )
//    )
//
//  implicit val pickler: FromTo[AuthenticatedUserId] =
//    fromTo[String].bimap[AuthenticatedUserId](_.id, AuthenticatedUserId.apply)
//}
//
/////**
////  * This is a Connect-internal UserID generated by hashing a user's "Big 5" PII fields.
////  */
////final case class ConnectUserId(
////                                id: String
////                              ) extends AuthenticatedUserId {
////  require(ConnectUserId.validationRegexes.exists(_.pattern.matcher(id).matches), "Invalid user ID format.")
////}
////
////object ConnectUserId {
////
////  private val StrippedUuid = "^([a-f0-9]{32})$".r
////  private val LegacyUserId = "^([a-f0-9]{24})$".r // this should be deprecated as soon as possible
////
////  protected val validationRegexes = Seq(StrippedUuid, LegacyUserId)
////
////  implicit val format: Format[ConnectUserId] = FormatOps.asString(ConnectUserId.apply, _.id)
////  implicit val pickler: FromTo[ConnectUserId] = fromTo[String].bimap[ConnectUserId](_.id, ConnectUserId.apply)
////
////  def applyOption(
////                   id: String
////                 ): Option[ConnectUserId] = Try(ConnectUserId.apply(id)).toOption
////
////  implicit val (path, query) =
////    Binders.bindPathAndQueryString[ConnectUserId]("ConnectUserId", new ConnectUserId(_), _.id)
////}
////
/////**
////  * This is a Rally-wide user identifier that can be correlated to IDs in other products.
////  */
////final case class RallyId(
////                          id: String
////                        ) extends AuthenticatedUserId {
////  require(RallyId.validationRegexes.exists(_.pattern.matcher(id).matches), "Invalid rally ID format.")
////}
////
////object RallyId {
////
////  private val ObjectId = "^([a-zA-Z0-9]{24})$".r
////
////  protected val validationRegexes = Seq(UserId.UUIDRegex, ObjectId)
////
////  implicit val format: Format[RallyId] = FormatOps.asString(RallyId.apply, _.id)
////  implicit val pickler: FromTo[RallyId] = fromTo[String].bimap[RallyId](_.id, RallyId.apply)
////
////  def applyOption(
////                   id: String
////                 ): Option[RallyId] = Try(RallyId.apply(id)).toOption
////
////  implicit val (path, query) = Binders.bindPathAndQueryString[RallyId]("RallyId", new RallyId(_), _.id)
////}
////
/////**
////  * This is a randomly generated Guest User ID for unauthenticated users.
////  *
////  * Note that in some instances this is known as a "Guest Session ID". Currently, the concept is one in the same for
////  * Connect guest users. Their user ID doubles as a session ID.
////  */
////final case class GuestUserId(
////                              id: String
////                            ) extends UserId {
////  require(GuestUserId.validationRegexes.exists(_.pattern.matcher(id).matches), "Invalid guest user ID format.")
////}
////
////object GuestUserId {
////
////  protected val validationRegexes = Seq("^(guest[0-9]{1,19})$|".r, UserId.UUIDRegex)
////
////  /**
////    * Current implementation simply generates a random ID for each guest on login. Alternatives might include location
////    * or machine-based identity detection (IP, user-agent, etc).
////    *
////    * Note: using [[ThreadLocalRandom]] instead of [[java.util.Random]] because Random has been observed to block
////    * when an instance is shared across threads, reducing performance. ThreadLocalRandom appears to be more thread-friendly.
////    *
////    * @return unique session identifier for a guest user, prefixed by 'guest'.
////    */
////  def random(): GuestUserId = GuestUserId("guest" + ThreadLocalRandom.current.nextLong(Long.MaxValue))
////
////  implicit val format: Format[GuestUserId] = FormatOps.asString(GuestUserId.apply, _.id)
////  implicit val pickler: FromTo[GuestUserId] = fromTo[String].bimap[GuestUserId](_.id, GuestUserId.apply)
////
////  def applyOption(
////                   id: String
////                 ): Option[GuestUserId] = Try(GuestUserId.apply(id)).toOption
////
////  implicit val (path, query) = Binders.bindPathAndQueryString[GuestUserId]("GuestUserId", new GuestUserId(_), _.id)
////}
